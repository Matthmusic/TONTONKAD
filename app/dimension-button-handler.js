/**
 * Gestionnaire pour les boutons "Appliquer dimensions"
 * Affiche et fait clignoter le bouton quand les dimensions changent
 */
(function initDimensionButtonHandler() {
    'use strict';
    
    // Valeurs initiales pour d√©tecter les changements
    let initialValues = {
        boxW: null,
        boxH: null,
        boxD: null
    };
    
    // R√©f√©rences aux √©l√©ments
    const elements = {
        boxW: null,
        boxH: null,
        boxD: null,
        applyRect: null,
        applyCirc: null,
        shape: null
    };
    
    // Timers pour g√©rer les animations
    let blinkTimers = {
        rect: null,
        circ: null
    };
    
    /**
     * Initialise les r√©f√©rences aux √©l√©ments DOM
     */
    function initElements() {
        elements.boxW = document.getElementById('boxW');
        elements.boxH = document.getElementById('boxH');
        elements.boxD = document.getElementById('boxD');
        elements.applyRect = document.getElementById('apply');
        elements.applyCirc = document.getElementById('applyCirc');
        elements.shape = document.getElementById('shape');
        
        // Debug : v√©rifier que les √©l√©ments sont trouv√©s
        console.log('üîç √âl√©ments trouv√©s:', {
            boxW: !!elements.boxW,
            boxH: !!elements.boxH,
            boxD: !!elements.boxD,
            applyRect: !!elements.applyRect,
            applyCirc: !!elements.applyCirc,
            shape: !!elements.shape
        });
        
        // Stocker les valeurs initiales
        if (elements.boxW) initialValues.boxW = parseFloat(elements.boxW.value) || 1000;
        if (elements.boxH) initialValues.boxH = parseFloat(elements.boxH.value) || 1000;
        if (elements.boxD) initialValues.boxD = parseFloat(elements.boxD.value) || 1000;
        
        console.log('üìä Valeurs initiales:', initialValues);
    }
    
    /**
     * V√©rifie si les valeurs rectangulaires ont chang√©
     */
    function hasRectValuesChanged() {
        if (!elements.boxW || !elements.boxH) return false;
        
        const currentW = parseFloat(elements.boxW.value) || 0;
        const currentH = parseFloat(elements.boxH.value) || 0;
        
        return currentW !== initialValues.boxW || currentH !== initialValues.boxH;
    }
    
    /**
     * V√©rifie si la valeur circulaire a chang√©
     */
    function hasCircValueChanged() {
        if (!elements.boxD) return false;
        
        const currentD = parseFloat(elements.boxD.value) || 0;
        return currentD !== initialValues.boxD;
    }
    
    /**
     * Affiche le bouton (pulse automatique via CSS)
     */
    function showButton(button, timerKey) {
        if (!button) return;
        
        // Arr√™ter le timer pr√©c√©dent s'il existe
        if (blinkTimers[timerKey]) {
            clearTimeout(blinkTimers[timerKey]);
        }
        
        // Afficher le bouton avec animation
        button.classList.remove('hidden', 'hide');
        button.classList.add('show');
        
        // Le pulse se fait automatiquement via CSS :not(.hidden):not(.success)
    }
    
    /**
     * Cache un bouton avec animation
     */
    function hideButton(button, timerKey) {
        if (!button) return;
        
        // Arr√™ter le clignotement
        if (blinkTimers[timerKey]) {
            clearTimeout(blinkTimers[timerKey]);
            blinkTimers[timerKey] = null;
        }
        
        button.classList.remove('blink', 'show');
        button.classList.add('hide');
        
        // Cacher compl√®tement apr√®s l'animation
        setTimeout(() => {
            button.classList.add('hidden');
            button.classList.remove('hide');
        }, 200);
    }
    
    /**
     * Met √† jour l'affichage du bouton rectangulaire
     */
    function updateRectButton() {
        const hasChanged = hasRectValuesChanged();
        console.log('üîÑ updateRectButton - hasChanged:', hasChanged);
        
        if (hasChanged) {
            console.log('‚úÖ Affichage bouton rect');
            showButton(elements.applyRect, 'rect');
        } else {
            console.log('‚ùå Masquage bouton rect');
            hideButton(elements.applyRect, 'rect');
        }
    }
    
    /**
     * Met √† jour l'affichage du bouton circulaire
     */
    function updateCircButton() {
        const hasChanged = hasCircValueChanged();
        console.log('üîÑ updateCircButton - hasChanged:', hasChanged);
        
        if (hasChanged) {
            console.log('‚úÖ Affichage bouton circ');
            showButton(elements.applyCirc, 'circ');
        } else {
            console.log('‚ùå Masquage bouton circ');
            hideButton(elements.applyCirc, 'circ');
        }
    }
    
    /**
     * Remet √† jour les valeurs initiales apr√®s application
     */
    function updateInitialValues() {
        if (elements.boxW) initialValues.boxW = parseFloat(elements.boxW.value) || 1000;
        if (elements.boxH) initialValues.boxH = parseFloat(elements.boxH.value) || 1000;
        if (elements.boxD) initialValues.boxD = parseFloat(elements.boxD.value) || 1000;
    }
    
    /**
     * Gestionnaire pour les clics sur les boutons d'application
     */
    function handleApplyClick(button, timerKey, updateCallback) {
        return function(event) {
            // Nettoyer les timers si n√©cessaire
            if (blinkTimers[timerKey]) {
                clearTimeout(blinkTimers[timerKey]);
                blinkTimers[timerKey] = null;
            }
            
            // Animation de succ√®s (arr√™te automatiquement le pulse via :not(.success))
            button.classList.add('success');
            
            // Mettre √† jour les valeurs initiales
            updateInitialValues();
            
            // Appeler le callback original s'il existe
            if (updateCallback && typeof updateCallback === 'function') {
                updateCallback(event);
            }
            
            // Cacher le bouton apr√®s l'animation de succ√®s
            setTimeout(() => {
                button.classList.remove('success');
                hideButton(button, timerKey);
            }, 400);
        };
    }
    
    /**
     * Gestionnaire pour la touche Entr√©e sur les inputs
     */
    function handleInputKeydown(event, buttonElement, timerKey, updateCallback) {
        if (event.key === 'Enter') {
            event.preventDefault();
            
            // Si le bouton est visible, l'activer
            if (buttonElement && !buttonElement.classList.contains('hidden')) {
                // Simuler un clic sur le bouton
                const clickEvent = new Event('click', { bubbles: true });
                buttonElement.dispatchEvent(clickEvent);
            }
        }
    }
    
    /**
     * Initialise les √©v√©nements
     */
    function initEvents() {
        // √âv√©nements sur les inputs
        if (elements.boxW) {
            elements.boxW.addEventListener('input', updateRectButton);
            elements.boxW.addEventListener('change', updateRectButton);
            elements.boxW.addEventListener('keydown', (e) => 
                handleInputKeydown(e, elements.applyRect, 'rect')
            );
        }
        
        if (elements.boxH) {
            elements.boxH.addEventListener('input', updateRectButton);
            elements.boxH.addEventListener('change', updateRectButton);
            elements.boxH.addEventListener('keydown', (e) => 
                handleInputKeydown(e, elements.applyRect, 'rect')
            );
        }
        
        if (elements.boxD) {
            elements.boxD.addEventListener('input', updateCircButton);
            elements.boxD.addEventListener('change', updateCircButton);
            elements.boxD.addEventListener('keydown', (e) => 
                handleInputKeydown(e, elements.applyCirc, 'circ')
            );
        }
        
        // √âv√©nements sur les boutons d'application
        if (elements.applyRect) {
            // Sauvegarder l'ancien gestionnaire s'il existe
            const originalRectHandler = elements.applyRect.onclick;
            elements.applyRect.onclick = null;
            
            elements.applyRect.addEventListener('click', 
                handleApplyClick(elements.applyRect, 'rect', originalRectHandler)
            );
        }
        
        if (elements.applyCirc) {
            // Sauvegarder l'ancien gestionnaire s'il existe
            const originalCircHandler = elements.applyCirc.onclick;
            elements.applyCirc.onclick = null;
            
            elements.applyCirc.addEventListener('click', 
                handleApplyClick(elements.applyCirc, 'circ', originalCircHandler)
            );
        }
        
        // √âv√©nement sur le changement de forme
        if (elements.shape) {
            elements.shape.addEventListener('change', (e) => {
                console.log('üîÑ Changement de forme:', e.target.value);
                
                // Cacher tous les boutons lors du changement de forme
                hideButton(elements.applyRect, 'rect');
                hideButton(elements.applyCirc, 'circ');
                
                // Mettre √† jour les valeurs initiales et v√©rifier les boutons
                setTimeout(() => {
                    console.log('‚è∞ Timeout apr√®s changement de forme');
                    updateInitialValues();
                    // V√©rifier imm√©diatement si les boutons doivent √™tre affich√©s
                    updateRectButton();
                    updateCircButton();
                }, 150); // Augment√© √† 150ms pour laisser le temps au DOM de se mettre √† jour
            });
        } else {
            console.log('‚ö†Ô∏è √âl√©ment shape non trouv√© !');
        }
    }
    
    /**
     * Fonction publique pour r√©initialiser les valeurs
     * Peut √™tre appel√©e depuis l'ext√©rieur si n√©cessaire
     */
    function resetInitialValues() {
        updateInitialValues();
        hideButton(elements.applyRect, 'rect');
        hideButton(elements.applyCirc, 'circ');
    }
    
    /**
     * Initialisation principale
     */
    function init() {
        // Attendre que le DOM soit charg√©
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
            return;
        }
        
        initElements();
        initEvents();
        
        // Exposer la fonction de reset globalement si n√©cessaire
        window.resetDimensionButtons = resetInitialValues;
        
        console.log('‚úÖ Gestionnaire des boutons de dimensions initialis√©');
    }
    
    // D√©marrer l'initialisation
    init();
})();